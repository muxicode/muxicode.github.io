---
title: æ’åº-5-å¿«é€Ÿæ’åº
autoGroup-1: ğŸŒ±é˜¶æ®µä¸€ï¼šåˆå‡ºèŒ…åºğŸŒ±
---

# å¿«é€Ÿæ’åº

ğŸ¤” **å¿«é€Ÿæ’åºçš„åŸºæœ¬åŸç†**

å¿«é€Ÿæ’åºçš„æ ¸å¿ƒæ€æƒ³æ˜¯åˆ†æ²»æ³•ï¼Œå°†ä¸€ä¸ªå¤§é—®é¢˜æ‹†è§£æˆå°é—®é¢˜æ¥è§£å†³ã€‚æ•´ä¸ªæ’åºè¿‡ç¨‹åˆ†ä¸ºä¸¤ä¸ªä¸»è¦æ­¥éª¤ï¼š**åˆ’åˆ†** å’Œ **é€’å½’æ’åº**ã€‚

1. **åˆ’åˆ†ï¼ˆPartitionï¼‰ï¼š** é€‰æ‹©ä¸€ä¸ªåŸºå‡†å…ƒç´ ï¼Œå°†æ•°ç»„åˆ†ä¸ºä¸¤ä¸ªå­æ•°ç»„ï¼Œå°äºåŸºå‡†çš„æ”¾å·¦è¾¹ï¼Œå¤§äºåŸºå‡†çš„æ”¾å³è¾¹ã€‚è¿™æ ·ï¼ŒåŸºå‡†å…ƒç´ å°±æ‰¾åˆ°äº†å®ƒåœ¨æ’åºåçš„æœ€ç»ˆä½ç½®ã€‚
2. **é€’å½’æ’åºï¼š** å¯¹å·¦å³ä¸¤ä¸ªå­æ•°ç»„åˆ†åˆ«è¿›è¡Œå¿«é€Ÿæ’åºï¼Œé€’å½’åœ°é‡å¤è¿™ä¸ªè¿‡ç¨‹ï¼Œç›´åˆ°æ•´ä¸ªæ•°ç»„æœ‰åºã€‚

ğŸ’¡ **ä¸ºä»€ä¹ˆå¿«é€Ÿæ’åºå¿«é€Ÿï¼Ÿ**

å¿«é€Ÿæ’åºä¹‹æ‰€ä»¥å¿«é€Ÿï¼Œå…³é”®åœ¨äºå®ƒçš„**åˆ’åˆ†è¿‡ç¨‹ç›¸å¯¹é«˜æ•ˆ**ã€‚åœ¨åˆ’åˆ†æ—¶ï¼Œ**ä¸éœ€è¦é¢å¤–çš„å­˜å‚¨ç©ºé—´**ï¼Œåªéœ€è¦åœ¨åŸåœ°è¿›è¡Œå…ƒç´ äº¤æ¢ï¼Œå¤§å¤§**å‡å°‘äº†ç©ºé—´å¤æ‚åº¦**ã€‚

## è·å…°å›½æ——é—®é¢˜

![](/g1_sort_5_quick_sort.assets/quick_sort.drawio.png)


ğŸŒ **è·å…°å›½æ——é—®é¢˜ï¼šæ•°ç»„ä¸‰éƒ¨æ›²** ğŸš©

åœ¨ä¸€ç‰‡æ— åºçš„æ•°ç»„ä¸­ï¼Œæˆ‘ä»¬è¯¥å¦‚ä½•å·§å¦™åœ°å°†å®ƒåˆ’åˆ†æˆå°äºåŒºã€ç­‰äºåŒºã€å¤§äºåŒºè¿™ä¸‰ä¸ªéƒ¨åˆ†å‘¢ï¼Ÿè¿™å¯æ˜¯ä¸€ä¸ªéå¸¸æœ‰è¶£çš„æŒ‘æˆ˜ï¼Œä¹Ÿè¢«ç§°ä¸ºè·å…°å›½æ——é—®é¢˜ã€‚

### ç®—æ³•æµç¨‹

![](/g1_sort_5_quick_sort.assets/quick_sort_1.drawio.png)

ğŸŒˆ **ç”¨æ•°ç»„ç»˜åˆ¶è·å…°å›½æ——** ğŸ¨

ğŸ§© è¿™æ¬¡æˆ‘ä»¬è¦ç”¨ä¸Šè¿°æ•°ç»„æ¥ç©è½¬è·å…°å›½æ——åˆ’åˆ†ã€‚å’±ä»¬çš„æŠ€å·§æ˜¯ä½¿ç”¨æ•°ç»„çš„æœ€åä¸€ä¸ªæ•°å­—ï¼Œä½œä¸ºç­‰äºåŒºåŸŸçš„æ ‡å¿—æ•°å­—ã€‚å‡†å¤‡å¥½äº†å—ï¼Ÿè¿™é‡Œè¦å¼•å…¥ä¸‰ä¸ªå°åŠ©æ‰‹ï¼š

- ğŸš¦ **å°äºåŒºåŸŸçš„ä½ç½® (less)**ï¼šä¸€å¼€å§‹å®ƒåœ¨-1çš„ä½ç½®ï¼Œéšç€éå†çš„è¿›è¡Œï¼Œå®ƒä¼šå‘å³ä¸æ–­æ‰©å¼ ã€‚

- ğŸš€ **å¤§äºåŒºåŸŸçš„ä½ç½® (more)**ï¼šå®ƒçš„èµ·å§‹ç‚¹æ˜¯æ•°ç»„æœ€å³è¾¹8çš„ä½ç½®ï¼Œå› ä¸º8ç°åœ¨æ˜¯æˆ‘ä»¬çš„åˆ†ç•Œçº¿ï¼Œè¦å…ˆæ’é™¤ã€‚

- ğŸ” **å½“å‰éå†çš„ä½ç½® (index)**ï¼šæˆ‘ä»¬ä»å·¦å‘å³éå†ï¼Œæ ¹æ®æ•°å€¼çš„å¤§å°å°†æ•°å­—åˆ’å…¥ä¸åŒçš„åŒºé—´ã€‚

![](/g1_sort_5_quick_sort.assets/quick_sort_2.drawio.png)

å½“å‰ä½ç½®`index`ä»å·¦å‘å³éå†æ•°ç»„ï¼Œå¹¶åˆ’åˆ†åŒºåŸŸï¼š

![](/g1_sort_5_quick_sort.assets/quick_sort_3.drawio.png)

## å¿«é€Ÿæ’åº


é€šè¿‡ä¸æ–­åœ°åˆ’åˆ†åŒºé—´ï¼Œæˆ‘ä»¬å¯ä»¥å®ç°è·å…°å›½æ——çš„ç¥å¥‡åˆ†å‰²ï¼Œæœ€ç»ˆè®©æ•°ç»„å˜å¾—æœ‰åºèµ·æ¥ã€‚

### é€’å½’ç‰ˆæœ¬

ğŸ§© **ç©è½¬é€’å½’ï¼šè·å…°å›½æ——ç‰ˆåŒºé—´åˆ’åˆ†** ğŸŒ

é€’å½’ï¼Œè¿™å°±æ˜¯æˆ‘ä»¬ç‚«é…·çš„åˆ©å™¨ï¼

```go
// å¿«æ’å…¥å£
func QuickSort(arr []int){
	quickProcess(arr, 0, len(arr)-1)
}

// å¿«æ’é€’å½’ï¼Œæ„æ€æ˜¯ç»™å®š arrï¼Œ l - r åŒºé—´æ’åºï¼Œå¹¶ä½¿æ•°ç»„æœ‰åº
func quickProcess(arr []int, l, r int){
	if l >= r {return}
	mL, mR := partition(arr, l, r)
	quickProcess(arr, l, mL-1)
	quickProcess(arr, mR+1, r)
}

// è·å…°å›½æ——é—®é¢˜
func partition(arr []int, l, r int) (int, int) {
	if len(arr) < 2{return 0 , 0} // base case åªæœ‰ä¸€ä¸ªæ•°çš„æ—¶å€™ä¸ç”¨åˆ’åˆ†åŒºé—´äº†
	lessArea := l-1
	biggerArea := r
	index := l
	rand.Seed(time.Now().UnixNano())
	ranIndex := l + rand.Intn(r-l+1)
	utility.Swap(arr, ranIndex, r)
	for index < biggerArea {
		if arr[index] < arr[r] {
			utility.Swap(arr, index, lessArea+1)
			index++
			lessArea++
		} else if arr[index] > arr[r] {
			utility.Swap(arr, index, biggerArea-1)
			biggerArea--
		} else {
			index++
		}
	}
	utility.Swap(arr, biggerArea, r)
	// è¿”å›ç­‰äºåŒºå·¦å³è¾¹ç•Œ
	return lessArea+1, biggerArea
}
```

å·¥å…·æ–¹æ³•ï¼š

```go
package utility

func Swap(arr []int, i, j int) {
	arr[i], arr[j] = arr[j], arr[i]
}
```

### è¿­ä»£ç‰ˆæœ¬

ğŸ§© **ç©è½¬è¿­ä»£ï¼šè·å…°å›½æ——ç‰ˆåŒºé—´åˆ’åˆ†** ğŸŒ

æ ˆæ˜¯æˆ‘ä»¬ä¿®æ”¹é€’å½’çš„åˆ©å™¨ï¼

```go
func QuickSort2(arr []int){
	job := Job{left:0, right:len(arr)-1}
	stack := list.New() // ä½¿ç”¨æ ˆæ¨¡æ‹Ÿé€’å½’çš„å †æ ˆä¿¡æ¯
	stack.PushBack(job)
	for stack.Len() > 0 {
		job := stack.Remove(stack.Back()).(Job)
		mL, mR := partition(arr, job.left, job.right)
		if mL-1 > job.left {
			stack.PushBack(Job{left:job.left, right: mL-1})
		}
		if mR+1 < job.right {
			stack.PushBack(Job{left:mR+1, right: job.right})
		}
	}
}

type Job struct { // ä¿å­˜é€’å½’æ—¶å¯¹åº”çš„å‚æ•°
	left int
	right int
}
```

### æµ‹è¯•ä»£ç 

```go
package sort

import (
	"github.com/stretchr/testify/assert"
	"sort"
	"testing"
	"traning/algorithm/utility"
)

func TestQuickSort(t *testing.T) {
	a := assert.New(t)
	testTime := 50000       // æµ‹è¯•æ¬¡æ•°
	testArrMaxLen := 100    // éšæœºæ•°ç»„çš„æœ€å¤§é•¿åº¦[0, testArrMaxLen)
	testArrMaxNum := 1000   // éšæœºæ•°ç»„ä¸­æœ€å¤§çš„æ•°å­—[0, testArrMaxNum)
	randomCreator := utility.GetRandomNumCreator()  // åˆå§‹åŒ–éšæœºæ•°ç»„ç”Ÿæˆå™¨
	for i:=0; i<testTime; i++ { // å¼€å§‹æµ‹è¯•ï¼Œæ€»å…±æµ‹è¯•50ä¸‡æ¬¡
		// ç”Ÿæˆä¸€ä¸ª é•¿åº¦ä¸º [0, testArrMaxLen) æ•°å­—å¤§å°ä¸º [0, testArrMaxNum) çš„éšæœºæ•°ç»„
		ranArr := randomCreator.GetRandomArr(testArrMaxNum, testArrMaxLen)
		// æ‹·è´æ•°ç»„ç”¨äºè¿›è¡Œæ ¡éªŒ
		arr1 := utility.CopyArr(ranArr)
		arr2 := utility.CopyArr(ranArr)
		arr3 := utility.CopyArr(ranArr)
		QuickSort(arr1) // æˆ‘ä»¬è‡ªå·±å®ç°çš„é€‰æ‹©æ’åºï¼Œå¯¹arr1è¿›è¡Œæ’åº
		QuickSort2(arr3)
		sort.Ints(arr2)  // ç³»ç»Ÿä¸¥æ ¼æ­£ç¡®çš„æ’åºæ–¹æ³•ï¼Œå¯¹arr2è¿›è¡Œæ’åº
		a.True(utility.ArrEqual(arr1, arr2)) // å¦‚æœæˆ‘ä»¬çš„æ’åºçš„æ–¹å¼ä¸ä¸¥æ ¼æ­£ç¡®çš„æ’åºä¸ä¸€è‡´ï¼Œåˆ™æˆ‘ä»¬çš„ç®—æ³•å¤±è´¥
		a.True(utility.ArrEqual(arr3, arr2)) // å¦‚æœæˆ‘ä»¬çš„æ’åºçš„æ–¹å¼ä¸ä¸¥æ ¼æ­£ç¡®çš„æ’åºä¸ä¸€è‡´ï¼Œåˆ™æˆ‘ä»¬çš„ç®—æ³•å¤±è´¥
	}
}
```

éšæœºæ•°ç»„ç”Ÿæˆå™¨ï¼š

```go
package utility

import (
	"math/rand"
	"time"
)


func GetRandomNumCreator() RandomNumCreator {
	return RandomNumCreator{
		time.Now().UnixNano(),
	}
}

type RandomNumCreator struct {
	Seed int64
}

func (r *RandomNumCreator) GetRandom(maxNum int) int {
	rand.Seed(r.Seed)
	r.Seed++
	return rand.Intn(maxNum)
}

func (r *RandomNumCreator)GetRandomArr(maxNum, maxLen int) []int {
	arrLen := r.GetRandom(maxLen)
	arr := make([]int, arrLen)
	for i:=0 ;i<arrLen; i++ {
		arr[i] = r.GetRandom(maxNum)
	}
	return arr
}
```


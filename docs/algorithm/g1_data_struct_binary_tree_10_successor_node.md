---
title: äºŒå‰æ ‘-8-åç»§èŠ‚ç‚¹
autoGroup-1: ğŸŒ±é˜¶æ®µä¸€ï¼šåˆå‡ºèŒ…åºğŸŒ±
---

# ğŸŒŸäºŒå‰æ ‘çš„åç»§èŠ‚ç‚¹ğŸŒŸ

äºŒå‰æ ‘çš„åç»§èŠ‚ç‚¹æŒ‡çš„æ˜¯åœ¨ä¸­åºéå†ä¸­ï¼ŒæŸä¸ªèŠ‚ç‚¹çš„åä¸€ä¸ªèŠ‚ç‚¹ã€‚åœ¨äºŒå‰æ ‘ä¸­ï¼Œæ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰ä¸€ä¸ªæŒ‡å‘å…¶çˆ¶èŠ‚ç‚¹çš„æŒ‡é’ˆã€‚åç»§èŠ‚ç‚¹å¯ä»¥å¸®åŠ©æˆ‘ä»¬åœ¨äºŒå‰æœç´¢æ ‘ä¸­æ‰¾åˆ°ä¸€ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ã€‚

## ğŸ“ˆä¾‹å­

è€ƒè™‘ä¸‹é¢è¿™æ£µäºŒå‰æ ‘ï¼š

```
        5
       / /
      3   8
     / / / /
    2  4 6  9
```

å¯¹äºèŠ‚ç‚¹ 3ï¼Œå®ƒçš„åç»§èŠ‚ç‚¹æ˜¯ 4ï¼›èŠ‚ç‚¹ 4 çš„åç»§èŠ‚ç‚¹æ˜¯ 5ï¼›èŠ‚ç‚¹ 5 çš„åç»§èŠ‚ç‚¹æ˜¯ 6ã€‚

## ğŸ’¼é¢˜ç›®

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘çš„èŠ‚ç‚¹ï¼ˆåŒ…å«çˆ¶èŠ‚ç‚¹æŒ‡é’ˆï¼‰ï¼Œè¯·æ‰¾å‡ºè¯¥èŠ‚ç‚¹çš„åç»§èŠ‚ç‚¹ã€‚

## ğŸŒŸåº”ç”¨

1. **æ–‡ä»¶ç³»ç»Ÿ**

   åœ¨æ–‡ä»¶ç³»ç»Ÿçš„å®ç°ä¸­ï¼Œæ–‡ä»¶å’Œç›®å½•å¯ä»¥è¢«ç»„ç»‡æˆæ ‘å½¢ç»“æ„ã€‚å½“æˆ‘ä»¬éœ€è¦åœ¨æ–‡ä»¶ç³»ç»Ÿä¸­æŸ¥æ‰¾æŸä¸ªæ–‡ä»¶çš„ä¸‹ä¸€ä¸ªæ–‡ä»¶æ—¶ï¼Œåç»§èŠ‚ç‚¹çš„æ¦‚å¿µå°±éå¸¸æœ‰ç”¨ã€‚

2. **çº¿ç¨‹è°ƒåº¦**

   åœ¨æ“ä½œç³»ç»Ÿä¸­ï¼Œçº¿ç¨‹å¯ä»¥è¢«ç»„ç»‡æˆçº¿ç¨‹æ ‘ã€‚å¯»æ‰¾çº¿ç¨‹çš„åç»§èŠ‚ç‚¹å¯ä»¥å¸®åŠ©æ“ä½œç³»ç»Ÿè¿›è¡Œçº¿ç¨‹è°ƒåº¦ï¼Œä»è€Œä¼˜åŒ–ç³»ç»Ÿçš„æ€§èƒ½ã€‚

3. **æ•°æ®åº“ç´¢å¼•**

   åœ¨æ•°æ®åº“ä¸­ï¼Œç´¢å¼•å¯ä»¥è¢«ç»„ç»‡æˆæ ‘å½¢ç»“æ„ã€‚å½“æˆ‘ä»¬éœ€è¦æŸ¥æ‰¾æŸä¸ªé”®çš„ä¸‹ä¸€ä¸ªé”®æ—¶ï¼Œåç»§èŠ‚ç‚¹çš„æ¦‚å¿µå¯ä»¥å¸®åŠ©æˆ‘ä»¬å¿«é€Ÿåœ°è¿›è¡Œæ•°æ®åº“æ£€ç´¢ã€‚

## ğŸ“ ç®—æ³•å›¾è§£

1. å¦‚æœè¯¥èŠ‚ç‚¹æœ‰å³å­èŠ‚ç‚¹ï¼Œåˆ™åç»§èŠ‚ç‚¹æ˜¯å³å­æ ‘ä¸­çš„æœ€å·¦èŠ‚ç‚¹ã€‚
2. å¦‚æœè¯¥èŠ‚ç‚¹æ²¡æœ‰å³å­èŠ‚ç‚¹ï¼Œä½†å®ƒæ˜¯å…¶çˆ¶èŠ‚ç‚¹çš„å·¦å­èŠ‚ç‚¹ï¼Œåˆ™åç»§èŠ‚ç‚¹æ˜¯å…¶çˆ¶èŠ‚ç‚¹ã€‚
3. å¦‚æœè¯¥èŠ‚ç‚¹æ—¢æ²¡æœ‰å³å­èŠ‚ç‚¹ï¼Œä¸”æ˜¯å…¶çˆ¶èŠ‚ç‚¹çš„å³å­èŠ‚ç‚¹ï¼Œåˆ™éœ€è¦æ²¿ç€çˆ¶èŠ‚ç‚¹å‘ä¸Šéå†ï¼Œç›´åˆ°æ‰¾åˆ°ä¸€ä¸ªèŠ‚ç‚¹æ˜¯å…¶çˆ¶èŠ‚ç‚¹çš„å·¦å­èŠ‚ç‚¹ä¸ºæ­¢ã€‚é‚£ä¸ªçˆ¶èŠ‚ç‚¹å°±æ˜¯åç»§èŠ‚ç‚¹ã€‚

![](/g1_data_struct_binary_tree_10_successor_node.assets/binary_tree_sucessor_node.drawio.png)

## ğŸš€ Goè¯­è¨€å®ç°

ä»£ç ï¼š

```go
package binary_tree

type TreeNodeWithParent struct {
	Val    int
	Left   *TreeNodeWithParent
	Right  *TreeNodeWithParent
	Parent *TreeNodeWithParent
}

func FindSuccessorNode(node *TreeNodeWithParent) *TreeNodeWithParent {
	if node == nil {
		return nil
	}
	if node.Right != nil { // å¦‚æœå­˜åœ¨å³å­æ ‘ï¼Œåˆ™å³å­©å­æœ€å·¦èŠ‚ç‚¹ä¸ºåç»§èŠ‚ç‚¹
		return findMostLeftNode(node.Right)
	}
	// æ²¡æœ‰å³å­©å­ï¼Œæ­¤æ—¶éœ€è¦å‘ä¸Šæ‰¾çˆ¶äº²èŠ‚ç‚¹ï¼Œç›´åˆ°ä¸€ä¸ªèŠ‚ç‚¹æ—¶æœŸçˆ¶äº²çš„å·¦èŠ‚ç‚¹ä¸ºæ­¢
	cur := node
	parent := cur.Parent
	for parent != nil && parent.Left != cur { // å‘ä¸Šæ‰¾çˆ¶äº²èŠ‚ç‚¹ï¼Œç›´åˆ°ä¸€ä¸ªèŠ‚ç‚¹æ—¶æœŸçˆ¶äº²çš„å·¦èŠ‚ç‚¹ä¸ºæ­¢
		cur = parent
		parent = cur.Parent
	}
	return parent // æ²¡æœ‰åç»§èŠ‚ç‚¹æ—¶ï¼Œçˆ¶èŠ‚ç‚¹ä¸ºnil
}

func findMostLeftNode(node *TreeNodeWithParent) *TreeNodeWithParent {
	cur := node
	for cur.Left != nil {
		cur = cur.Left
	}
	return cur
}
```

è°ƒè¯•ï¼š

```go
package binary_tree

import (
	"fmt"
	"testing"
)

func TestFindSuccessorNode(t *testing.T) {
	// Construct the binary tree
	root := &TreeNodeWithParent{Val: 5}
	root.Left = &TreeNodeWithParent{Val: 3, Parent: root}
	root.Right = &TreeNodeWithParent{Val: 8, Parent: root}
	root.Left.Left = &TreeNodeWithParent{Val: 2, Parent: root.Left}
	root.Left.Right = &TreeNodeWithParent{Val: 4, Parent: root.Left}
	root.Right.Left = &TreeNodeWithParent{Val: 6, Parent: root.Right}
	root.Right.Right = &TreeNodeWithParent{Val: 9, Parent: root.Right}

	// Example: Finding the successor of node 3
	successor := FindSuccessorNode(root.Left.Right)
	if successor != nil {
		fmt.Println("The successor of node 4 is:", successor.Val)
	} else {
		fmt.Println("Node 3 has no successor")
	}
}
```
